import { NextRequest, NextResponse } from "next/server";
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  BorderStyle,
} from "docx";

interface QuestionInput {
  id: string;
  text: string;
  category: string;
  mandatory: boolean;
  confidence: number;
}

interface ResponseInput {
  questionId: string;
  draft: string;
  editedContent?: string;
  status: string;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      rfpTitle,
      issuingOrganization,
      submissionDeadline,
      questions,
      responses,
      companyName,
    } = body;

    const children: Paragraph[] = [];

    // Title page
    children.push(
      new Paragraph({ spacing: { after: 600 } }),
      new Paragraph({
        children: [
          new TextRun({
            text: companyName || "Company Name",
            bold: true,
            size: 28,
            color: "8b5cf6",
          }),
        ],
        alignment: AlignmentType.CENTER,
      }),
      new Paragraph({ spacing: { after: 200 } }),
      new Paragraph({
        children: [
          new TextRun({ text: "Response to", size: 22, color: "666666", italics: true }),
        ],
        alignment: AlignmentType.CENTER,
      }),
      new Paragraph({
        children: [
          new TextRun({ text: rfpTitle || "Request for Proposal", bold: true, size: 36 }),
        ],
        alignment: AlignmentType.CENTER,
      }),
      new Paragraph({
        children: [
          new TextRun({ text: `Issued by: ${issuingOrganization || "N/A"}`, size: 22, color: "666666" }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 100 },
      })
    );

    if (submissionDeadline) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: `Deadline: ${submissionDeadline}`, size: 22, color: "666666" }),
          ],
          alignment: AlignmentType.CENTER,
        })
      );
    }

    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `Prepared: ${new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}`,
            size: 20,
            color: "999999",
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      }),
      new Paragraph({
        border: { bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" } },
        spacing: { after: 400 },
      })
    );

    // Build response lookup
    const responseMap: Record<string, ResponseInput> = {};
    if (responses) {
      for (const r of responses) {
        responseMap[r.questionId] = r;
      }
    }

    // Group by category
    const grouped: Record<string, QuestionInput[]> = {};
    for (const q of questions || []) {
      const cat = q.category || "General";
      if (!grouped[cat]) grouped[cat] = [];
      grouped[cat].push(q);
    }

    for (const [category, catQuestions] of Object.entries(grouped)) {
      children.push(
        new Paragraph({
          text: category,
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 400, after: 200 },
        })
      );

      for (const q of catQuestions) {
        const response = responseMap[q.id];

        children.push(
          new Paragraph({
            text: `${q.id}. ${q.text}`,
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 300, after: 100 },
          }),
          new Paragraph({
            children: [
              new TextRun({
                text: `${q.mandatory ? "Mandatory" : "Optional"} | Confidence: ${q.confidence}%`,
                italics: true,
                size: 18,
                color: "888888",
              }),
            ],
            spacing: { after: 100 },
          })
        );

        const text = response?.editedContent || response?.draft;
        if (text) {
          text.split("\n").forEach((line: string) => {
            children.push(new Paragraph({ children: [new TextRun({ text: line, size: 22 })], spacing: { after: 80 } }));
          });
        } else {
          children.push(
            new Paragraph({
              children: [new TextRun({ text: "[Response pending]", italics: true, color: "999999", size: 22 })],
              spacing: { after: 80 },
            })
          );
        }

        children.push(
          new Paragraph({
            border: { bottom: { style: BorderStyle.SINGLE, size: 1, color: "EEEEEE" } },
            spacing: { after: 200 },
          })
        );
      }
    }

    children.push(
      new Paragraph({ spacing: { before: 600 } }),
      new Paragraph({
        children: [
          new TextRun({ text: "Generated by BidCraft", italics: true, size: 18, color: "AAAAAA" }),
        ],
        alignment: AlignmentType.CENTER,
      })
    );

    const doc = new Document({ sections: [{ children }] });
    const buffer = await Packer.toBuffer(doc);
    const uint8 = new Uint8Array(buffer);

    return new NextResponse(uint8, {
      headers: {
        "Content-Type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "Content-Disposition": `attachment; filename="${rfpTitle || "RFP-Responses"}.docx"`,
      },
    });
  } catch (error: unknown) {
    console.error("DOCX export error:", error);
    return NextResponse.json(
      { error: "Failed to generate document" },
      { status: 500 }
    );
  }
}
